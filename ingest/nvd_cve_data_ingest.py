import datetime
import json
import os
from pathlib import Path
# import pytz
import requests
from requests.exceptions import HTTPError
import time
import zipfile

from db.database import CVE
from env_vars import cve_data_dir

"""
This module is used to download the initial NVD Data Feeds required for the app and write those to a Postgres DB.
Steps:
1. Download the ZIP files.
2. Extract CVEs from data files and format into record format.
3. Write records to db.
4. Delete the ZIP files.
"""

def download_all_cve_json():
    """
    Data is from NIST National Vulnerability Database
    Download format is .zip
    https://nvd.nist.gov/feeds/json/cve/1.1/<name_of_json_zip>
    """
    base_url = "https://nvd.nist.gov/feeds/json/cve/1.1"

    # Make cve data download dir if not exists
    if not cve_data_dir.is_dir():
        print(f"'nvd_cve_data directory' at {cve_data_dir} is not present.\n Commencing full cve zip download.")
        os.mkdir(cve_data_dir)
    
    current_year = int(datetime.date.today().strftime("%Y"))
    # Download each yearly cve zip
    for year in range(2002, current_year+1):
        year_path = f"/nvdcve-1.1-{year}.json.zip"
        download_url = f"{base_url}{year_path}"

        zip_file_name = year_path.replace("/", "")
        zip_file_path = cve_data_dir / zip_file_name

        # only download if the file does not exist
        if not zip_file_path.is_file():
            print(f"Downloading zip file from '{download_url}'")
            response = requests.get(download_url, allow_redirects=True)
            with open(f"{zip_file_path}", "wb") as file_handle:
                file_handle.write(response.content)
            # Sleep for thirty seconds between requests because the api may rate limit us.
            time.sleep(30)
        else:
            print(f"'{download_url}' has already been downloaded.\n File is located at '{zip_file_path}'")

        print("Zip file download complete.")

def extract_zip(zip_file_path, directory_to_extract_to):
    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
        zip_ref.extractall(directory_to_extract_to)
    unzipped_file_name_str = str(zip_file_path).replace(".zip", "")
    return Path(unzipped_file_name_str)

def write_cve_json_to_db(cve_json_zip_file_path):
    """
    Write all cves in a json file to db and delete JSON file.
    This is okay because we currently maintain the zip file.
    This is a function that accesses the database so it must be called with the app.app_context()

    Records to CVE JSON for Reference:
    - id = generated by SQLAlchemy
        - cve_id = cve["CVE_data_meta"]["ID"]
        - description = description["description_data"][0]["value"]
        - cvss_v3_version = impact["baseMetricV3"]["cvssV3"]["version"]
        - cvss_v3_vector_string = impact["baseMetricV3"]["cvssV3"]["vectorString"]
        - cvss_v3_attack_vector = impact["baseMetricV3"]["cvssV3"]["attackVector"]
        - cvss_v3_attack_complexity = impact["baseMetricV3"]["cvssV3"]["attackComplexity"]
        - cvss_v3_privileges_required = impact["baseMetricV3"]["cvssV3"]["privilegesRequired"]
        - cvss_v3_user_interaction = impact["baseMetricV3"]["cvssV3"]["userInteraction"]
        - cvss_v3_scope = impact["baseMetricV3"]["cvssV3"]["scope"]
        - cvss_v3_confidentiality_impact = impact["baseMetricV3"]["cvssV3"]["confidentialityImpact"]
        - cvss_v3_integrity_impact = impact["baseMetricV3"]["cvssV3"]["integrityImpact"]
        - cvss_v3_availability_impact = impact["baseMetricV3"]["cvssV3"]["availabilityImpact"]
        - cvss_v3_base_score = impact["baseMetricV3"]["cvssV3"]["baseScore"]
        - cvss_v3_base_severity = impact["baseMetricV3"]["cvssV3"]["baseSeverity"]
        - base_metric_v3_exploitability_score = impact["baseMetricV3"]["exploitabilityScore"]
        - base_metric_v3_impact_score = impact["baseMetricV3"]["impactScore"]
        - cvss_v2_version = impact["baseMetricV2"]["cvssV2"]["version"]
        - cvss_v2_vector_string = impact["baseMetricV2"]["cvssV2"]["vectorString"]
        - cvss_v2_access_vector = impact["baseMetricV2"]["cvssV2"]["accessVector"]
        - cvss_v2_access_complexity = impact["baseMetricV2"]["cvssV2"]["accessComplexity"]
        - cvss_v2_authentication = impact["baseMetricV2"]["cvssV2"]["authentication"]
        - cvss_v2_confidentiality_impact = impact["baseMetricV2"]["cvssV2"]["confidentialityImpact"]
        - cvss_v2_integrity_impact = impact["baseMetricV2"]["cvssV2"]["integrityImpact"]
        - cvss_v2_availability_impact = impact["baseMetricV2"]["cvssV2"]["availabilityImpact"]
        - cvss_v2_base_score = impact["baseMetricV2"]["cvssV2"]["baseScore"]
        - base_metric_v2_severity = impact["baseMetricV2"]["severity"]
        - base_metric_v2_exploitability_score = impact["baseMetricV2"]["exploitabilityScore"]
        - base_metric_v2_impact_score = impact["baseMetricV2"]["impactScore"]
        - base_metric_v2_obtain_all_privilege = impact["baseMetricV2"]["obtainAllPrivilege"]
        - base_metric_v2_obtain_user_privilege = impact["baseMetricV2"]["obtainUserPrivilege"]
        - base_metric_v2_obtain_other_privilege = impact["baseMetricV2"]["obtainOtherPrivilege"]
        - base_metric_v2_user_interaction_required = impact["baseMetricV2"]["userInteractionRequired"]
        - published_date = publishedDate
        - last_modified_date = lastModifiedDate
        - full_cve_json = ["CVE_Items"][0]
        - record_creation_date = generated by SQLAlchemy


    """
    unzipped_file_path = extract_zip(cve_json_zip_file_path, cve_data_dir)

    with open(unzipped_file_path) as json_file:
        cve_data = json.load(json_file)

    for item in cve_data["CVE_Items"]:
        cve_item = item["cve"]
        cve_id = cve_item["CVE_data_meta"]["ID"]
        record_last_modified_date = item["lastModifiedDate"]

        # cve records are written from json zip files by year beginning with 2002 file(contains pre-2002 also) and ending with
        # the most recent json zip file from the current year.
        # this means that we will write multiple records for each cve if there are more than one.
        # for updates to prevent rewrites we check the last_modified_date and compare it to the most recent last_modified_date from table records
        # this ensures on initial hydration that all records are written but on updates multiple duplicate records are not ingested.
        db_cve = CVE.get_last_modified_record_by_cve_id(nvd_cve_id=cve_id)
        db_cve_last_modified_date = datetime.datetime.min
        if db_cve:
            db_cve_last_modified_date = db_cve.last_modified_date
        # date string example:  "2010-12-16T05:00Z"
        date_string = record_last_modified_date
        date_string_split_list = date_string.split("-")

        year = int(date_string_split_list[0])
        month = int(date_string_split_list[1])

        extract_list = date_string_split_list[2].replace("T", "-T-").split("-")

        day = int(extract_list[0])
        time_split = extract_list[2].replace("Z", "").split(":")
        hour = int(time_split[0])
        minute = int(time_split[1])

        record_last_modified_datetime = datetime.datetime(
            year, 
            month, 
            day, 
            hour,
            minute,
            # offset-naive or offset-aware...that is the question
            # tzinfo=pytz.UTC
            tzinfo=None
        )


        if record_last_modified_datetime > db_cve_last_modified_date:
            record_cve_id = cve_id
            record_description = cve_item["description"]["description_data"][0]["value"]
            # some older records do not have cvss v3 metrics
            if item["impact"].get("baseMetricV3", None) is not None:
                record_cvss_v3_version = item["impact"]["baseMetricV3"]["cvssV3"]["version"]
                record_cvss_v3_vector_string = item["impact"]["baseMetricV3"]["cvssV3"]["vectorString"]
                record_cvss_v3_attack_vector = item["impact"]["baseMetricV3"]["cvssV3"]["attackVector"]
                record_cvss_v3_attack_complexity = item["impact"]["baseMetricV3"]["cvssV3"]["attackComplexity"]
                record_cvss_v3_privileges_required = item["impact"]["baseMetricV3"]["cvssV3"]["privilegesRequired"]
                record_cvss_v3_user_interaction = item["impact"]["baseMetricV3"]["cvssV3"]["userInteraction"]
                record_cvss_v3_scope = item["impact"]["baseMetricV3"]["cvssV3"]["scope"]
                record_cvss_v3_confidentiality_impact = item["impact"]["baseMetricV3"]["cvssV3"]["confidentialityImpact"]
                record_cvss_v3_integrity_impact = item["impact"]["baseMetricV3"]["cvssV3"]["integrityImpact"]
                record_cvss_v3_availability_impact = item["impact"]["baseMetricV3"]["cvssV3"]["availabilityImpact"]
                record_cvss_v3_base_score = item["impact"]["baseMetricV3"]["cvssV3"]["baseScore"]
                record_cvss_v3_base_severity = item["impact"]["baseMetricV3"]["cvssV3"]["baseSeverity"]
                record_base_metric_v3_exploitability_score = item["impact"]["baseMetricV3"]["exploitabilityScore"]
                record_base_metric_v3_impact_score = item["impact"]["baseMetricV3"]["impactScore"]
            else:
                record_cvss_v3_version = None
                record_cvss_v3_vector_string = None
                record_cvss_v3_attack_vector = None
                record_cvss_v3_attack_complexity = None
                record_cvss_v3_privileges_required = None
                record_cvss_v3_user_interaction = None
                record_cvss_v3_scope = None
                record_cvss_v3_confidentiality_impact = None
                record_cvss_v3_integrity_impact = None
                record_cvss_v3_availability_impact = None
                record_cvss_v3_base_score = None
                record_cvss_v3_base_severity = None
                record_base_metric_v3_exploitability_score = None
                record_base_metric_v3_impact_score = None

            if item["impact"].get("baseMetricV2"):
                record_cvss_v2_version = item["impact"]["baseMetricV2"]["cvssV2"]["version"]
                record_cvss_v2_vector_string = item["impact"]["baseMetricV2"]["cvssV2"]["vectorString"]
                record_cvss_v2_access_vector = item["impact"]["baseMetricV2"]["cvssV2"]["accessVector"]
                record_cvss_v2_access_complexity = item["impact"]["baseMetricV2"]["cvssV2"]["accessComplexity"]
                record_cvss_v2_authentication = item["impact"]["baseMetricV2"]["cvssV2"]["authentication"]
                record_cvss_v2_confidentiality_impact = item["impact"]["baseMetricV2"]["cvssV2"]["confidentialityImpact"]
                record_cvss_v2_integrity_impact = item["impact"]["baseMetricV2"]["cvssV2"]["integrityImpact"]
                record_cvss_v2_availability_impact = item["impact"]["baseMetricV2"]["cvssV2"]["availabilityImpact"]
                record_cvss_v2_base_score = item["impact"]["baseMetricV2"]["cvssV2"]["baseScore"]
                record_base_metric_v2_severity = item["impact"]["baseMetricV2"]["severity"]
                record_base_metric_v2_exploitability_score = item["impact"]["baseMetricV2"]["exploitabilityScore"]
                record_base_metric_v2_impact_score = item["impact"]["baseMetricV2"]["impactScore"]
                record_base_metric_v2_obtain_all_privilege = item["impact"]["baseMetricV2"]["obtainAllPrivilege"]
                record_base_metric_v2_obtain_user_privilege = item["impact"]["baseMetricV2"]["obtainUserPrivilege"]
                record_base_metric_v2_obtain_other_privilege = item["impact"]["baseMetricV2"]["obtainOtherPrivilege"]
                record_base_metric_v2_user_interaction_required = item["impact"]["baseMetricV2"]["userInteractionRequired"]
            else:
                record_cvss_v2_version = None
                record_cvss_v2_vector_string = None
                record_cvss_v2_access_vector = None
                record_cvss_v2_access_complexity = None
                record_cvss_v2_authentication = None
                record_cvss_v2_confidentiality_impact = None
                record_cvss_v2_integrity_impact = None
                record_cvss_v2_availability_impact = None
                record_cvss_v2_base_score = None
                record_base_metric_v2_severity = None
                record_base_metric_v2_exploitability_score = None
                record_base_metric_v2_impact_score = None
                record_base_metric_v2_obtain_all_privilege = None
                record_base_metric_v2_obtain_user_privilege = None
                record_base_metric_v2_obtain_other_privilege = None
                record_base_metric_v2_user_interaction_required = None

            record_published_date = item["publishedDate"]
            record_full_cve_json = item

            cve_to_write = CVE(
                cve_id=record_cve_id,
                description=record_description,
                cvss_v3_version=record_cvss_v3_version,
                cvss_v3_vector_string=record_cvss_v3_vector_string,
                cvss_v3_attack_vector=record_cvss_v3_attack_vector,
                cvss_v3_attack_complexity=record_cvss_v3_attack_complexity,
                cvss_v3_privileges_required=record_cvss_v3_privileges_required,
                cvss_v3_user_interaction=record_cvss_v3_user_interaction,
                cvss_v3_scope=record_cvss_v3_scope,
                cvss_v3_confidentiality_impact=record_cvss_v3_confidentiality_impact,
                cvss_v3_integrity_impact=record_cvss_v3_integrity_impact,
                cvss_v3_availability_impact=record_cvss_v3_availability_impact,
                cvss_v3_base_score=record_cvss_v3_base_score,
                cvss_v3_base_severity=record_cvss_v3_base_severity,
                base_metric_v3_exploitability_score=record_base_metric_v3_exploitability_score,
                base_metric_v3_impact_score=record_base_metric_v3_impact_score,
                cvss_v2_version=record_cvss_v2_version,
                cvss_v2_vector_string=record_cvss_v2_vector_string,
                cvss_v2_access_vector=record_cvss_v2_access_vector,
                cvss_v2_access_complexity=record_cvss_v2_access_complexity,
                cvss_v2_authentication=record_cvss_v2_authentication,
                cvss_v2_confidentiality_impact=record_cvss_v2_confidentiality_impact,
                cvss_v2_integrity_impact=record_cvss_v2_integrity_impact,
                cvss_v2_availability_impact=record_cvss_v2_availability_impact,
                cvss_v2_base_score=record_cvss_v2_base_score,
                base_metric_v2_severity=record_base_metric_v2_severity,
                base_metric_v2_exploitability_score=record_base_metric_v2_exploitability_score,
                base_metric_v2_impact_score=record_base_metric_v2_impact_score,
                base_metric_v2_obtain_all_privilege=record_base_metric_v2_obtain_all_privilege,
                base_metric_v2_obtain_user_privilege=record_base_metric_v2_obtain_user_privilege,
                base_metric_v2_obtain_other_privilege=record_base_metric_v2_obtain_other_privilege,
                base_metric_v2_user_interaction_required=record_base_metric_v2_user_interaction_required,
                published_date=record_published_date,
                last_modified_date=record_last_modified_date,
                full_cve_json=record_full_cve_json
            )
            cve_to_write.save()

    os.remove(unzipped_file_path)

def write_all_cve_json_zip_to_db():
    """
    Searches cve_data directory for all files with .json.zip in file name.
    For each file found it extracts the .zip, opens file, reads in json, parses json to create CVE object, writes CVE object as record in cve table.
    """
    if not CVE.query.limit(1).all():
        print("Writing initial CVEs to db from zip.")
        current_year = int(datetime.date.today().strftime("%Y"))
        # write records for each cve in each yearly cve zip
        for year in range(2002, current_year+1):
            zip_file_name = f"nvdcve-1.1-{year}.json.zip"
            zip_file_path = cve_data_dir / zip_file_name

            # extracts zip to json and writes cves to db
            write_cve_json_to_db(cve_json_zip_file_path=zip_file_path)
    else:
        print("CVE table has been hydrated with initial CVEs.")

def download_and_hydrate_cve():
    download_all_cve_json()
    write_all_cve_json_zip_to_db()


def is_cve_modified_feed_updated():
    """
    Checks if modified cve feed has been updated since our last pull of the modified feed.
    Tasks:
        - Download the meta file.
        - Retrieve the value for key "lastModifiedDate"
        - Convert that string to datetime.datetime
        - Get the time our last modified zip was modified.
            - os.path.getmtime(path)
        - If lastModifedDate is more recent than our local files last mtime then return True
        - Else return False

    Download url for meta file: 
    https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-modified.meta

    Output: bool
        True if update is required
    """
    base_url = "https://nvd.nist.gov/feeds/json/cve/1.1"
    meta_path = "nvdcve-1.1-modified.meta"

    try:
        response = requests.get(f"{base_url}/{meta_path}")
        # If the response was successful, no Exception will be raised
        response.raise_for_status()
        response_text = response.text
        # TODO: Find a better way to create a datetime.datetime
        last_modified_split_list = response_text.split("\r")[0]
        last_modified_split_1 = last_modified_split_list.split(":")[1].split("T")
        last_modified_date_split = last_modified_split_1[0].split("-")
        last_modified_year = last_modified_date_split[0]
        last_modified_month = last_modified_date_split[1]
        last_modified_day = last_modified_date_split[2]
        last_modified_time = last_modified_split_1[1] + ":" + last_modified_split_list.split(":")[2]
        last_modified_time_split = last_modified_time.split(":")
        last_modified_hour = last_modified_time_split[0]
        last_modified_minute = last_modified_time_split[1]

        last_modified_datetime_obj = datetime.datetime(year=int(last_modified_year), month=int(last_modified_month), day=int(last_modified_day),
        hour=int(last_modified_hour), minute=int(last_modified_minute))

        # TODO: ^ Find a better way to create a datetime.datetime
        # nvdcve-1.1-modified.json.zip
        modified_cve_path = f"nvdcve-1.1-modified.json.zip"
        download_url = f"{base_url}/{modified_cve_path}"

        zip_file_name = modified_cve_path
        zip_file_path = cve_data_dir / zip_file_name

        if os.path.isfile(zip_file_path):
            modified_zip_modified_time = datetime.datetime.fromtimestamp(os.path.getmtime(zip_file_path))
            return last_modified_datetime_obj > modified_zip_modified_time
        else:
            return True

    except HTTPError as http_err:
        print(f'HTTP error occurred: {http_err}')
    except Exception as err:
        print(f'Other error occurred: {err}')


def ensure_cve_modified_feed_is_updated():
    """
    If update is available:
        download zip and write cves to cve table.
    """
    if is_cve_modified_feed_updated():
        base_url = "https://nvd.nist.gov/feeds/json/cve/1.1"
        modified_cve_path = f"nvdcve-1.1-modified.json.zip"
        download_url = f"{base_url}/{modified_cve_path}"

        print(f"Downloading zip file from '{download_url}'")
        response = requests.get(download_url, allow_redirects=True)
        zip_file_path = cve_data_dir / modified_cve_path
        with open(f"{zip_file_path}", "wb") as file_handle:
            file_handle.write(response.content)

        write_cve_json_to_db(zip_file_path)
    else:
        print("CVE modified feed has not been updated since last download.")






